Overview:
- Dining Philosophers simulation implemented in Java, Python, and C to illustrate deadlock avoidance and starvation detection.

How it’s solved:
- Five philosopher threads; chopsticks modeled as mutexes/locks.
- Asymmetric pickup (even: left→right, odd: right→left) plus timeout; if both not acquired in time, release and retry.
- Run for a configurable duration; report meals, last-meal time, and deadlock/starvation status.

Requirements satisfaction:
- Threads used to represent philosophers; synchronization via locks.
- Deterministic logic with randomized think/eat durations in bounded ranges.
- Handles parameterization of durations/timeouts.

Basic Viva Questions:
Q: What is the Dining Philosophers problem?
A: Five philosophers sit at a circular table with one chopstick between each pair. They think and eat, needing two chopsticks to eat. The challenge is to avoid deadlock and starvation.

Q: What is deadlock and what are its four necessary conditions?
A: Deadlock is when processes are stuck waiting for resources held by each other. Four conditions: (1) mutual exclusion, (2) hold-and-wait, (3) no preemption, (4) circular wait.

Q: What is starvation and how does it differ from deadlock?
A: Starvation is when a process never gets the resources it needs (indefinite postponement), even though the system is progressing. Deadlock is when no process makes progress.

Q: What is a semaphore and what are the two main types?
A: A semaphore is a synchronization primitive with a counter. A binary semaphore has values 0/1 (lock). A counting semaphore has arbitrary non-negative values (resource pool).

Q: What is a lock (mutex) and how does it prevent race conditions?
A: A lock (mutex) ensures only one thread holds it at a time. A thread must acquire the lock before entering a critical section; others wait. This prevents concurrent access and race conditions.

Q: What is synchronization doing here?
A: Synchronization ensures that only one philosopher can hold a chopstick at a time using locks/mutexes. This prevents two philosophers from grabbing the same chopstick simultaneously, avoiding conflicts and ensuring safe access to shared resources.

Q: Why asymmetric pickup reduces circular wait.
A: Asymmetric pickup: alternating left/right acquisition breaks the cycle of identical 
resource ordering, removing one condition for circular wait and reducing deadlock risk.

Q: How timeout prevents hold-and-wait deadlock.
A: Timeout: bounded wait on the second chopstick forces release and retry, so no thread can hold one resource indefinitely while waiting for the other; this releases locks to let others proceed.

Q: What metrics indicate starvation vs healthy progress.
A: Metrics: count meals per philosopher and track time since last meal; starvation is flagged when last-meal age exceeds a threshold while others still eat; healthy progress shows all philosophers eating periodically with non-zero meal counts.


Q: How semaphores would change the solution and trade-offs.
A: Semaphores: a single counting semaphore at `N-1` gates entry, ensuring at most four philosophers compete for five forks, which guarantees no deadlock but changes fairness; per-fork semaphores behave like mutexes. Trade-off: simpler proof of safety but less fine-grained control over pickup strategy and potential throughput reduction.
