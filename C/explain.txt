Overview:
- Multi-level queue CPU scheduler simulation with 3 queues: RR (Q0), SRTF (Q1), FCFS (Q2).

How it’s solved:
- Parse process list file: `PID ARRIVAL BURST QUEUE`.
- Maintain per-queue ready lists and a current running process; apply preemption rules (higher priority ready or better SRTF candidate).
- Track per-process metrics (start, completion, turnaround, waiting, response) and overall CPU utilization/throughput.

Requirements satisfaction:
- Different scheduling per queue with clear priority ordering.
- Deterministic results given the same input and quantum.
- Handles empty intervals by jumping to next arrival to avoid idle loops.

Basic Viva Questions:
Q: What is CPU scheduling and why is it important?
A: CPU scheduling decides which process runs next on the CPU. It is important to maximize CPU utilization, fairness, responsiveness, and minimize wait time.

Q: What is the difference between preemptive and non-preemptive scheduling?
A: Preemptive scheduling can interrupt a running process to run a higher-priority process. Non-preemptive scheduling lets a process run until it voluntarily releases the CPU.

Q: What is the time quantum in Round Robin scheduling?
A: The time quantum is the maximum time slice a process gets before being preempted. It ensures fair distribution of CPU time among processes.

Q: What is turnaround time and waiting time?
A: Turnaround time = completion time - arrival time (total time in the system). Waiting time = turnaround time - burst time (time spent waiting for CPU).

Q: What is CPU utilization and throughput?
A: CPU utilization = (total CPU busy time / total elapsed time) × 100%. Throughput = number of processes completed per unit time.

Q: What are the three queues in this multi-level scheduler and their algorithms?
A: Queue 0 uses Round Robin (fair time slicing), Queue 1 uses SRTF (shortest remaining time first), and Queue 2 uses FCFS (first-come first-served).

Viva prompts:
- Why choose RR/SRTF/FCFS and how do they differ?
- How is preemption handled across queues and within SRTF?
- How do we compute CPU utilization and throughput?
- Edge cases: simultaneous arrivals, zero quantum, all jobs in one queue.
- How would you add aging or dynamic queue movement?
Answers:
- RR/SRTF/FCFS: RR keeps short interactive tasks responsive via time slicing, SRTF minimizes average waiting for medium jobs by always running the shortest remaining time, FCFS keeps long/batch jobs simple and non-preemptive; priority is Q0>Q1>Q2 so interactivity wins.
- Preemption: any ready job in a higher queue preempts the runner; within Q1, a newly arrived process with shorter remaining time preempts the current SRTF job; Q0 preempts Q1/Q2 on quantum expiry or arrival, Q2 only runs when others are empty.
- Utilization/throughput: utilization = busy_time/finish_time where busy_time is total executed quanta, finish_time is last completion timestamp; throughput = completed_processes/finish_time; per-process turnaround = completion-arrival, waiting = turnaround-burst, response = first_start-arrival.
- Edge cases: simultaneous arrivals are ordered by queue priority then PID to stay deterministic; zero quantum is rejected/treated as error to avoid infinite preemption loop; if all jobs sit in one queue, scheduler collapses to that policy (pure RR, SRTF, or FCFS).
- Aging/dynamic movement: decay a process’s priority when it waits past a threshold by promoting Q2→Q1→Q0; demote CPU hogs on repeated full quanta without completion; store wait counters and move between queues on a timer tick.
